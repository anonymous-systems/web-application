import { ChangeDetectionStrategy, Component, effect, Input, output, } from '@angular/core';
import { NewFolderDialogComponent, } from './components/new-folder-dialog/new-folder-dialog.component';
import { SelectionModel } from '@angular/cdk/collections';
import { DeleteFilesDialogComponent, } from './components/delete-files-dialog/delete-files-dialog.component';
import { AsyncPipe, DatePipe, NgClass } from '@angular/common';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatTableModule } from '@angular/material/table';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { StorageItemIconComponent, } from './components/storage-item-icon/storage-item-icon.component';
import { FormatBytesPipe } from './pipes/format-bytes.pipe';
import { StorageFilePreviewComponent, } from './components/storage-file-preview/storage-file-preview.component';
import { FileDropzoneDirective } from './directives/file-dropzone.directive';
import { LoadingOrErrorComponent, } from './components/loading-or-error/loading-or-error.component';
import { first } from 'rxjs';
import { toSignal } from '@angular/core/rxjs-interop';
import * as i0 from "@angular/core";
import * as i1 from "@angular/material/dialog";
import * as i2 from "./services/console-logger.service";
import * as i3 from "./services/firebase-storage.service";
import * as i4 from "@angular/material/button";
import * as i5 from "@angular/material/icon";
import * as i6 from "@angular/material/table";
import * as i7 from "@angular/material/checkbox";
export class FileManagerComponent {
    constructor(dialog, cLog, storageService) {
        this.dialog = dialog;
        this.cLog = cLog;
        this.storageService = storageService;
        /**
         * The columns to display in the file management table.
         */
        this.tableColumns = ['checkbox', 'name', 'size', 'type', 'lastModified'];
        /**
         * The current path within the storage system.
         */
        this.currentPath = '';
        /**
         * Used for managing multiple item selection within the file manager.
         */
        this.selection = new SelectionModel(true, []);
        /**
         * The root path within the storage system where the file manager operates.
         */
        this.rootStoragePath = '';
        this.selectionChangeSignal = toSignal(this.selection.changed);
        this.selectionChange = output();
        effect(() => {
            const selectionChange = this.selectionChangeSignal();
            this.selectionChange.emit(selectionChange?.source.selected || null);
        });
    }
    ngOnInit() {
        /** Sets the initial path within the storage system */
        this.currentPath = this.rootStoragePath;
        /** Fetches the initial storage items */
        this.items$ = this.getAllStorageItems(this.currentPath);
    }
    /**
     * Downloads the provided files by triggering download links.
     * @param {StorageItem[]} files - The files to download.
     */
    async downloadFiles(files) {
        await this.storageService.openAllFiles(files);
    }
    /**
     * Toggles the selection of all items in the file listing.
     *
     * @param {boolean} checked - Whether to select or deselect all items.
     * @param {StorageItem[]} items - The list of file items.
     */
    toggleAllItems(checked, items) {
        if (!checked) {
            this.selection.clear();
            return;
        }
        this.selection.select(...items);
    }
    /**
     * Checks if all items in the file listing are currently selected.
     *
     * @param {StorageItem[]} items - The list of file items.
     * @return {boolean} True if all items are selected, false otherwise.
     */
    allItemsSelected(items) {
        return this.selection.selected.length === items.length &&
            this.selection.selected.length > 0;
    }
    /**
     * Checks if some, but not all, items in the file listing are selected.
     *
     * @param {StorageItem[]} items - The list of file items.
     * @return {boolean} True if the selection state is indeterminate, false
     * otherwise.
     */
    allItemsIndeterminate(items) {
        return this.selection.selected.length > 0 &&
            this.selection.selected.length < items.length;
    }
    /**
     * Event handler for when a storage item is selected. Updates the navigation
     * if a folder is selected, or sets the selected file if a file is selected.
     *
     * @param {StorageItem} item - The selected StorageItem.
     */
    storageItemSelected(item) {
        if (item.type === 'folder')
            this.setStoragePath(item.fullPath);
        else if (item.type === 'file')
            this.selectedFile = item;
    }
    /**
     * Checks if the current selection includes at least one folder.
     *
     * @return {boolean} True if a folder is part of the selection, false
     * otherwise.
     */
    get selectionIncludesFolder() {
        return this.selection.selected.some((item) => item.type === 'folder');
    }
    /**
     * Opens a dialog to confirm deletion, and handles deleting selected items
     * if confirmed. Clears the selection and updates the file listing.
     *
     * @param {StorageItem[]} items - The items to delete.
     */
    deleteItems(items) {
        const dialogRef = this.dialog.open(DeleteFilesDialogComponent, {
            id: 'delete-files-dialog',
            minWidth: '250px',
        });
        dialogRef.afterClosed().pipe(first()).forEach((confirm) => {
            if (confirm) {
                this.storageService.deleteFiles(items)
                    .then(() => {
                    this.selection.clear();
                    if (items.some((item) => item == this.selectedFile)) {
                        this.selectedFile = undefined;
                    }
                })
                    .then(() => this.reload(this.currentPath));
            }
        });
    }
    /**
     * Constructs a breadcrumb-style path string based on the current path
     * history. Used for navigation display.
     *
     * @param {string[]} pathArray - An array of path segments.
     * @param {number} index - The index up to which path segments should be
     * included.
     * @return {string} The constructed path string.
     */
    getCrumbPath(pathArray, index) {
        pathArray.length = index + 1;
        return pathArray.join('/');
    }
    /**
     * Updates the current path and fetches the new file listing.
     * Clears any existing selection.
     *
     * @param {string} path - The new storage path.
     */
    setStoragePath(path) {
        this.items$ = this.getAllStorageItems(path);
        this.currentPath = path;
        if (this.selection.hasValue())
            this.selection.clear();
    }
    /**
     * Retrieves and processes all items within a given storage path.
     *
     * @param {string} path - The storage path to list.
     * @return {Promise<StorageItem[]>} A Promise resolving to the items,
     * or undefined in case of error.
     */
    async getAllStorageItems(path) {
        const storageRef = this.storageService.getRef(path);
        return this.storageService.listAll(storageRef)
            .then(async ({ items, prefixes }) => {
            const allItems = [
                ...prefixes.map(this.storageService.importFolder),
                ...(await Promise.all(items.map(this.storageService.importFile))),
            ];
            return allItems;
        })
            .catch((error) => {
            this.error = error;
            return new Promise(() => undefined);
        });
    }
    /**
     * Reloads the file and folder listing within the current or specified path.
     *
     * @param {string | null} path - Optional. The path to reload. If null,
     * the current path is used.
     */
    reload(path = null) {
        let pathRef;
        if (path)
            pathRef = this.storageService.getRef(path);
        else
            pathRef = this.storageService.getRef(this.currentPath);
        this.items$ = this.storageService.listAll(pathRef)
            .then(async ({ items, prefixes }) => [
            ...prefixes.map(this.storageService.importFolder),
            ...(await Promise.all(items.map(this.storageService.importFile))),
        ]);
    }
    /**
     * Opens a dialog to create a new folder and updates folder listing
     * if successful.
     */
    createNewFolder() {
        const newFolderContract = {
            folderName: '',
            path: this.currentPath,
        };
        const dialogRef = this.dialog.open(NewFolderDialogComponent, {
            id: 'create-new-folder-dialog',
            width: '250px',
            data: newFolderContract,
        });
        dialogRef.afterClosed()
            .pipe(first())
            .forEach((contract) => {
            if (contract.folderName) {
                const path = this.currentPath ?
                    `${this.currentPath}/${contract.folderName}` : contract.folderName;
                this.setStoragePath(path);
            }
        });
    }
    /**
     * Handles file upload logic, including validation and updating the
     * file listing upon successful upload. Logs errors if encountered.
     *
     * @param {FileList} files - An optional FileList of files to upload.
     */
    async uploadItems(files) {
        if (!files)
            return;
        // prevent file names to have ","(comma)
        if (Array.from(files).some((file) => file.name.includes(','))) {
            this.cLog.warn(`File names cannot include a ","(comma)`);
            return;
        }
        const uploadedFiles = [];
        for (const file of Array.from(files)) {
            const fileRef = this.storageService
                .getRef(`${this.currentPath}/${file.name}`);
            await this.storageService.uploadFile(fileRef, file)
                .then((snapshot) => uploadedFiles.push(snapshot))
                .catch((error) => {
                return this.handleUploadError(error, file.name);
            });
        }
        if (!uploadedFiles.length)
            return;
        this.reload(this.currentPath);
        /* eslint-disable-next-line max-len */
        this.cLog.info(`Uploaded ${uploadedFiles.length} ${uploadedFiles.length === 1 ? 'file' : 'files'}`, uploadedFiles);
    }
    /**
     * Event handler for file input change. Triggers the upload process.
     *
     * @param {Event} $event - The file input change event.
     */
    async onFilesSelect($event) {
        const files = $event.target.files;
        await this.uploadItems(files);
    }
    /**
     * Handles logging of errors during the file upload process.
     *
     * @param {FirebaseError} error - The Firebase error object.
     * @param {string} filename - The name of the file that failed to upload.
     */
    handleUploadError(error, filename) {
        this.cLog.error(error.code === 'storage/unauthorized' ?
            'You do not have permission to upload' :
            `Error uploading file: '${filename}'`, error);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.3", ngImport: i0, type: FileManagerComponent, deps: [{ token: i1.MatDialog }, { token: i2.ConsoleLoggerService }, { token: i3.FirebaseStorageService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "18.1.3", type: FileManagerComponent, isStandalone: true, selector: "anon-file-manager", inputs: { selection: "selection", selectedFile: "selectedFile", rootStoragePath: "rootStoragePath" }, outputs: { selectionChange: "selectionChange" }, ngImport: i0, template: "@if (items$ | async; as items) {\n  <div class=\"card\">\n    <input #inputUpload multiple class=\"inputUpload\"\n           type=\"file\" autocomplete=\"off\" tabindex=\"-1\"\n           (change)=\"onFilesSelect($event)\" />\n     \n    @if (selection.isEmpty()) {\n      <header class=\"header\">\n        <!-- Crumbs -->\n        <span class=\"crumbs\">\n          <button mat-icon-button type=\"button\"\n                  [disabled]=\"currentPath===rootStoragePath\"\n                  (click)=\"setStoragePath(rootStoragePath)\">\n            <mat-icon fontIcon=\"home\" />\n          </button>\n           \n          @for (crumb of currentPath.split('/'); track crumb;let i=$index; let last=$last) {\n            @if (crumb !== rootStoragePath) {\n              @if (currentPath!==rootStoragePath) {\n                <mat-icon class=\"overflow-visible\" fontIcon=\"chevron_right\" />\n              }\n              <button mat-button type=\"button\" [disabled]=\"last\"\n                      (click)=\"setStoragePath(getCrumbPath(currentPath.split('/'), i))\">\n              {{crumb}}\n            </button>\n            }\n          }\n        </span>\n\n        <button mat-icon-button type=\"button\" (click)=\"reload()\">\n          <mat-icon fontIcon=\"refresh\" />\n        </button>\n        <button mat-icon-button type=\"button\" (click)=\"createNewFolder()\">\n          <mat-icon fontIcon=\"create_new_folder\" />\n        </button>\n        <div>\n          <button mat-flat-button type=\"button\" color=\"primary\"\n                  (click)=\"inputUpload.click()\">Upload</button>\n        </div>\n      </header>\n    } @else {\n      <header class=\"header items-selected\">\n        <button mat-icon-button type=\"button\" (click)=\"selection.clear()\">\n          <mat-icon fontIcon=\"close\" />\n        </button>\n        <span>{{selection.selected.length}} {{selection.selected.length === 1 ? 'item' : 'items'}}</span>\n         \n        <button mat-raised-button type=\"button\" color=\"accent\" [disabled]=\"selectionIncludesFolder\"\n                (click)=\"downloadFiles(selection.selected)\">Download files</button>\n        <button mat-stroked-button type=\"button\"\n                (click)=\"deleteItems(selection.selected)\">Delete</button>\n      </header>\n    }\n\n    <div class=\"content\">\n      <div class=\"table-sidebar\">\n        <div class=\"table-wrapper\" [ngClass]=\"{'grid-column-end-span-8': selectedFile}\">\n          <table mat-table [dataSource]=\"items\">\n            <!-- Checkbox Column -->\n            <ng-container matColumnDef=\"checkbox\">\n              <th *matHeaderCellDef mat-header-cell class=\"checkbox-column\">\n                 \n                <mat-checkbox name=\"select-all\" [checked]=\"allItemsSelected(items)\" [indeterminate]=\"allItemsIndeterminate(items)\"\n                              [disabled]=\"items.length === 0\"\n                              (change)=\"toggleAllItems($event.checked, items)\" />\n              </th>\n              <td *matCellDef=\"let item\" mat-cell class=\"checkbox-column\">\n                 \n                <mat-checkbox [checked]=\"selection.isSelected(item)\"\n                              (click)=\"$event.stopPropagation()\"\n                              (change)=\"selection.toggle(item)\" />\n              </td>\n            </ng-container>\n\n            <!-- Name Column -->\n            <ng-container matColumnDef=\"name\">\n              <th *matHeaderCellDef mat-header-cell> Name </th>\n              <td *matCellDef=\"let item\" mat-cell class=\"name-column\">\n                <anon-storage-item-icon [type]=\"item.type\" [contentType]=\"item.contentType\" />\n                <span>{{item.name}}</span>\n              </td>\n            </ng-container>\n\n            <!-- Size Column -->\n            <ng-container matColumnDef=\"size\">\n              <th *matHeaderCellDef mat-header-cell> Size </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? '&mdash;' : item.size | formatBytes}}\n              </td>\n            </ng-container>\n\n            <!-- Type Column -->\n            <ng-container matColumnDef=\"type\">\n              <th *matHeaderCellDef mat-header-cell> Type </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? 'Folder' : item.contentType}}\n              </td>\n            </ng-container>\n\n            <!-- Last Modified Column -->\n            <ng-container matColumnDef=\"lastModified\">\n              <th *matHeaderCellDef mat-header-cell> Last Modified </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? '&mdash;' : item.updated | date}}\n              </td>\n            </ng-container>\n\n            <tr *matHeaderRowDef=\"tableColumns; sticky: true\" mat-header-row></tr>\n            <tr *matRowDef=\"let item; columns: tableColumns;\" mat-row\n                [class.selected]=\"selectedFile === item\"\n                (click)=\"storageItemSelected(item)\"></tr>\n\n            <tr *matNoDataRow class=\"mat-row\">\n              <td class=\"mat-cell\" [attr.colspan]=\"tableColumns.length\">\n                <div anonFileDropzone class=\"empty-folder\"\n                     hoverClass=\"hovering\" tabindex=\"0\"\n                     (click)=\"inputUpload.click()\"\n                     (keyup)=\"inputUpload.click()\"\n                     (dropped)=\"uploadItems($event)\">\n                  <div>No files found</div>\n                  <div>Drag and drop files to upload</div>\n                </div>\n              </td>\n            </tr>\n          </table>\n        </div>\n\n        @if (selectedFile) {\n          <aside class=\"sidebar grid-column-end-span-4\">\n            <anon-storage-file-preview [item]=\"selectedFile\" (_close)=\"selectedFile = undefined\" />\n          </aside>\n        }\n      </div>\n    </div>\n  </div>\n} @else {\n  <anon-loading-or-error [error]=\"error\" />\n}\n", styles: [".card{display:flex;flex-direction:column;border-radius:1rem;overflow:hidden}header.header{height:56px;display:flex;align-items:center;justify-content:space-between;padding:0 1rem}header.header.items-selected{justify-content:flex-start;gap:1rem}header.header.items-selected mat-icon{color:inherit}.crumbs{flex-grow:1;display:flex;align-items:center;width:100px;overflow-x:auto;overflow-y:hidden}.inputUpload{display:none}.content{display:flex;flex-direction:column;overflow:hidden}.table-sidebar{width:100%;display:grid;margin:0;grid-gap:1.5rem;grid-template-columns:repeat(12,minmax(0,1fr));overflow:hidden}.table-wrapper{grid-column-end:span 12;border-top-width:1px;border-top-style:solid;border-bottom-width:1px;border-bottom-style:solid;display:inline-flex;flex-direction:column;overflow:auto;border-radius:0 0 8px 8px;width:100%}table{min-width:100%;border:0;white-space:nowrap;border-collapse:collapse;table-layout:fixed}.checkbox-column{width:64px}.name-column{max-width:50vw;display:flex;align-items:center;height:auto;min-height:52px;overflow-wrap:break-word;white-space:pre;padding:.75rem 1rem .75rem 0}.name-column span{display:-webkit-box;-webkit-line-clamp:1;-webkit-box-orient:vertical;overflow:hidden;width:100%}aside.sidebar{width:auto;margin:0}td{border:none!important}.mat-mdc-header-cell,.mat-mdc-cell{height:auto;min-height:52px;padding:0 1rem}.mat-mdc-row{cursor:pointer}.empty-folder{display:flex;flex-direction:column;justify-content:center;align-items:center;min-height:200px;height:100%}.grid-column-end-span-4{grid-column-end:span 4}.grid-column-end-span-8{grid-column-end:span 8}.grid-column-end-span-12{grid-column-end:span 12}\n"], dependencies: [{ kind: "pipe", type: AsyncPipe, name: "async" }, { kind: "ngmodule", type: MatButtonModule }, { kind: "component", type: i4.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", exportAs: ["matButton"] }, { kind: "component", type: i4.MatIconButton, selector: "button[mat-icon-button]", exportAs: ["matButton"] }, { kind: "ngmodule", type: MatIconModule }, { kind: "component", type: i5.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "ngmodule", type: MatTableModule }, { kind: "component", type: i6.MatTable, selector: "mat-table, table[mat-table]", exportAs: ["matTable"] }, { kind: "directive", type: i6.MatHeaderCellDef, selector: "[matHeaderCellDef]" }, { kind: "directive", type: i6.MatHeaderRowDef, selector: "[matHeaderRowDef]", inputs: ["matHeaderRowDef", "matHeaderRowDefSticky"] }, { kind: "directive", type: i6.MatColumnDef, selector: "[matColumnDef]", inputs: ["matColumnDef"] }, { kind: "directive", type: i6.MatCellDef, selector: "[matCellDef]" }, { kind: "directive", type: i6.MatRowDef, selector: "[matRowDef]", inputs: ["matRowDefColumns", "matRowDefWhen"] }, { kind: "directive", type: i6.MatHeaderCell, selector: "mat-header-cell, th[mat-header-cell]" }, { kind: "directive", type: i6.MatCell, selector: "mat-cell, td[mat-cell]" }, { kind: "component", type: i6.MatHeaderRow, selector: "mat-header-row, tr[mat-header-row]", exportAs: ["matHeaderRow"] }, { kind: "component", type: i6.MatRow, selector: "mat-row, tr[mat-row]", exportAs: ["matRow"] }, { kind: "directive", type: i6.MatNoDataRow, selector: "ng-template[matNoDataRow]" }, { kind: "ngmodule", type: MatCheckboxModule }, { kind: "component", type: i7.MatCheckbox, selector: "mat-checkbox", inputs: ["aria-label", "aria-labelledby", "aria-describedby", "id", "required", "labelPosition", "name", "value", "disableRipple", "tabIndex", "color", "checked", "disabled", "indeterminate"], outputs: ["change", "indeterminateChange"], exportAs: ["matCheckbox"] }, { kind: "component", type: StorageItemIconComponent, selector: "anon-storage-item-icon", inputs: ["type", "contentType"] }, { kind: "pipe", type: FormatBytesPipe, name: "formatBytes" }, { kind: "pipe", type: DatePipe, name: "date" }, { kind: "component", type: StorageFilePreviewComponent, selector: "anon-storage-file-preview", inputs: ["item"], outputs: ["_close"] }, { kind: "directive", type: FileDropzoneDirective, selector: "[anonFileDropzone]", inputs: ["hoverClass"], outputs: ["dropped", "hovered"] }, { kind: "component", type: LoadingOrErrorComponent, selector: "anon-loading-or-error", inputs: ["error"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.3", ngImport: i0, type: FileManagerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'anon-file-manager', standalone: true, imports: [
                        AsyncPipe,
                        MatButtonModule,
                        MatIconModule,
                        MatTableModule,
                        MatCheckboxModule,
                        StorageItemIconComponent,
                        FormatBytesPipe,
                        DatePipe,
                        StorageFilePreviewComponent,
                        FileDropzoneDirective,
                        LoadingOrErrorComponent,
                        NgClass,
                    ], changeDetection: ChangeDetectionStrategy.OnPush, template: "@if (items$ | async; as items) {\n  <div class=\"card\">\n    <input #inputUpload multiple class=\"inputUpload\"\n           type=\"file\" autocomplete=\"off\" tabindex=\"-1\"\n           (change)=\"onFilesSelect($event)\" />\n     \n    @if (selection.isEmpty()) {\n      <header class=\"header\">\n        <!-- Crumbs -->\n        <span class=\"crumbs\">\n          <button mat-icon-button type=\"button\"\n                  [disabled]=\"currentPath===rootStoragePath\"\n                  (click)=\"setStoragePath(rootStoragePath)\">\n            <mat-icon fontIcon=\"home\" />\n          </button>\n           \n          @for (crumb of currentPath.split('/'); track crumb;let i=$index; let last=$last) {\n            @if (crumb !== rootStoragePath) {\n              @if (currentPath!==rootStoragePath) {\n                <mat-icon class=\"overflow-visible\" fontIcon=\"chevron_right\" />\n              }\n              <button mat-button type=\"button\" [disabled]=\"last\"\n                      (click)=\"setStoragePath(getCrumbPath(currentPath.split('/'), i))\">\n              {{crumb}}\n            </button>\n            }\n          }\n        </span>\n\n        <button mat-icon-button type=\"button\" (click)=\"reload()\">\n          <mat-icon fontIcon=\"refresh\" />\n        </button>\n        <button mat-icon-button type=\"button\" (click)=\"createNewFolder()\">\n          <mat-icon fontIcon=\"create_new_folder\" />\n        </button>\n        <div>\n          <button mat-flat-button type=\"button\" color=\"primary\"\n                  (click)=\"inputUpload.click()\">Upload</button>\n        </div>\n      </header>\n    } @else {\n      <header class=\"header items-selected\">\n        <button mat-icon-button type=\"button\" (click)=\"selection.clear()\">\n          <mat-icon fontIcon=\"close\" />\n        </button>\n        <span>{{selection.selected.length}} {{selection.selected.length === 1 ? 'item' : 'items'}}</span>\n         \n        <button mat-raised-button type=\"button\" color=\"accent\" [disabled]=\"selectionIncludesFolder\"\n                (click)=\"downloadFiles(selection.selected)\">Download files</button>\n        <button mat-stroked-button type=\"button\"\n                (click)=\"deleteItems(selection.selected)\">Delete</button>\n      </header>\n    }\n\n    <div class=\"content\">\n      <div class=\"table-sidebar\">\n        <div class=\"table-wrapper\" [ngClass]=\"{'grid-column-end-span-8': selectedFile}\">\n          <table mat-table [dataSource]=\"items\">\n            <!-- Checkbox Column -->\n            <ng-container matColumnDef=\"checkbox\">\n              <th *matHeaderCellDef mat-header-cell class=\"checkbox-column\">\n                 \n                <mat-checkbox name=\"select-all\" [checked]=\"allItemsSelected(items)\" [indeterminate]=\"allItemsIndeterminate(items)\"\n                              [disabled]=\"items.length === 0\"\n                              (change)=\"toggleAllItems($event.checked, items)\" />\n              </th>\n              <td *matCellDef=\"let item\" mat-cell class=\"checkbox-column\">\n                 \n                <mat-checkbox [checked]=\"selection.isSelected(item)\"\n                              (click)=\"$event.stopPropagation()\"\n                              (change)=\"selection.toggle(item)\" />\n              </td>\n            </ng-container>\n\n            <!-- Name Column -->\n            <ng-container matColumnDef=\"name\">\n              <th *matHeaderCellDef mat-header-cell> Name </th>\n              <td *matCellDef=\"let item\" mat-cell class=\"name-column\">\n                <anon-storage-item-icon [type]=\"item.type\" [contentType]=\"item.contentType\" />\n                <span>{{item.name}}</span>\n              </td>\n            </ng-container>\n\n            <!-- Size Column -->\n            <ng-container matColumnDef=\"size\">\n              <th *matHeaderCellDef mat-header-cell> Size </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? '&mdash;' : item.size | formatBytes}}\n              </td>\n            </ng-container>\n\n            <!-- Type Column -->\n            <ng-container matColumnDef=\"type\">\n              <th *matHeaderCellDef mat-header-cell> Type </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? 'Folder' : item.contentType}}\n              </td>\n            </ng-container>\n\n            <!-- Last Modified Column -->\n            <ng-container matColumnDef=\"lastModified\">\n              <th *matHeaderCellDef mat-header-cell> Last Modified </th>\n              <td *matCellDef=\"let item\" mat-cell>\n                {{item.type === 'folder' ? '&mdash;' : item.updated | date}}\n              </td>\n            </ng-container>\n\n            <tr *matHeaderRowDef=\"tableColumns; sticky: true\" mat-header-row></tr>\n            <tr *matRowDef=\"let item; columns: tableColumns;\" mat-row\n                [class.selected]=\"selectedFile === item\"\n                (click)=\"storageItemSelected(item)\"></tr>\n\n            <tr *matNoDataRow class=\"mat-row\">\n              <td class=\"mat-cell\" [attr.colspan]=\"tableColumns.length\">\n                <div anonFileDropzone class=\"empty-folder\"\n                     hoverClass=\"hovering\" tabindex=\"0\"\n                     (click)=\"inputUpload.click()\"\n                     (keyup)=\"inputUpload.click()\"\n                     (dropped)=\"uploadItems($event)\">\n                  <div>No files found</div>\n                  <div>Drag and drop files to upload</div>\n                </div>\n              </td>\n            </tr>\n          </table>\n        </div>\n\n        @if (selectedFile) {\n          <aside class=\"sidebar grid-column-end-span-4\">\n            <anon-storage-file-preview [item]=\"selectedFile\" (_close)=\"selectedFile = undefined\" />\n          </aside>\n        }\n      </div>\n    </div>\n  </div>\n} @else {\n  <anon-loading-or-error [error]=\"error\" />\n}\n", styles: [".card{display:flex;flex-direction:column;border-radius:1rem;overflow:hidden}header.header{height:56px;display:flex;align-items:center;justify-content:space-between;padding:0 1rem}header.header.items-selected{justify-content:flex-start;gap:1rem}header.header.items-selected mat-icon{color:inherit}.crumbs{flex-grow:1;display:flex;align-items:center;width:100px;overflow-x:auto;overflow-y:hidden}.inputUpload{display:none}.content{display:flex;flex-direction:column;overflow:hidden}.table-sidebar{width:100%;display:grid;margin:0;grid-gap:1.5rem;grid-template-columns:repeat(12,minmax(0,1fr));overflow:hidden}.table-wrapper{grid-column-end:span 12;border-top-width:1px;border-top-style:solid;border-bottom-width:1px;border-bottom-style:solid;display:inline-flex;flex-direction:column;overflow:auto;border-radius:0 0 8px 8px;width:100%}table{min-width:100%;border:0;white-space:nowrap;border-collapse:collapse;table-layout:fixed}.checkbox-column{width:64px}.name-column{max-width:50vw;display:flex;align-items:center;height:auto;min-height:52px;overflow-wrap:break-word;white-space:pre;padding:.75rem 1rem .75rem 0}.name-column span{display:-webkit-box;-webkit-line-clamp:1;-webkit-box-orient:vertical;overflow:hidden;width:100%}aside.sidebar{width:auto;margin:0}td{border:none!important}.mat-mdc-header-cell,.mat-mdc-cell{height:auto;min-height:52px;padding:0 1rem}.mat-mdc-row{cursor:pointer}.empty-folder{display:flex;flex-direction:column;justify-content:center;align-items:center;min-height:200px;height:100%}.grid-column-end-span-4{grid-column-end:span 4}.grid-column-end-span-8{grid-column-end:span 8}.grid-column-end-span-12{grid-column-end:span 12}\n"] }]
        }], ctorParameters: () => [{ type: i1.MatDialog }, { type: i2.ConsoleLoggerService }, { type: i3.FirebaseStorageService }], propDecorators: { selection: [{
                type: Input
            }], selectedFile: [{
                type: Input
            }], rootStoragePath: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZS1tYW5hZ2VyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItZmlyZWJhc2Utc3RvcmFnZS1tYW5hZ2VyL3NyYy9saWIvZmlsZS1tYW5hZ2VyLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItZmlyZWJhc2Utc3RvcmFnZS1tYW5hZ2VyL3NyYy9saWIvZmlsZS1tYW5hZ2VyLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCx1QkFBdUIsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBVSxNQUFNLEdBQ2xFLE1BQU0sZUFBZSxDQUFDO0FBS3ZCLE9BQU8sRUFFTCx3QkFBd0IsR0FDekIsTUFBTSw0REFBNEQsQ0FBQztBQUVwRSxPQUFPLEVBQUMsY0FBYyxFQUFDLE1BQU0sMEJBQTBCLENBQUM7QUFDeEQsT0FBTyxFQUNMLDBCQUEwQixHQUMzQixNQUFNLGdFQUFnRSxDQUFDO0FBQ3hFLE9BQU8sRUFBQyxTQUFTLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBQzdELE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQUN6RCxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sd0JBQXdCLENBQUM7QUFDckQsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLHlCQUF5QixDQUFDO0FBQ3ZELE9BQU8sRUFBQyxpQkFBaUIsRUFBQyxNQUFNLDRCQUE0QixDQUFDO0FBQzdELE9BQU8sRUFDTCx3QkFBd0IsR0FDekIsTUFBTSw0REFBNEQsQ0FBQztBQUNwRSxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sMkJBQTJCLENBQUM7QUFDMUQsT0FBTyxFQUNMLDJCQUEyQixHQUM1QixNQUFNLGtFQUFrRSxDQUFDO0FBQzFFLE9BQU8sRUFBQyxxQkFBcUIsRUFBQyxNQUFNLHNDQUFzQyxDQUFDO0FBQzNFLE9BQU8sRUFDTCx1QkFBdUIsR0FDeEIsTUFBTSwwREFBMEQsQ0FBQztBQUVsRSxPQUFPLEVBQUMsS0FBSyxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBQzNCLE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSw0QkFBNEIsQ0FBQzs7Ozs7Ozs7O0FBdUJwRCxNQUFNLE9BQU8sb0JBQW9CO0lBd0MvQixZQUNVLE1BQWlCLEVBQ2pCLElBQTBCLEVBQzFCLGNBQXNDO1FBRnRDLFdBQU0sR0FBTixNQUFNLENBQVc7UUFDakIsU0FBSSxHQUFKLElBQUksQ0FBc0I7UUFDMUIsbUJBQWMsR0FBZCxjQUFjLENBQXdCO1FBMUNoRDs7V0FFRztRQUNILGlCQUFZLEdBQWEsQ0FBQyxVQUFVLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsY0FBYyxDQUFDLENBQUM7UUFNOUU7O1dBRUc7UUFDSCxnQkFBVyxHQUFHLEVBQUUsQ0FBQztRQU1qQjs7V0FFRztRQUVELGNBQVMsR0FBRyxJQUFJLGNBQWMsQ0FBYyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFReEQ7O1dBRUc7UUFFRCxvQkFBZSxHQUFHLEVBQUUsQ0FBQztRQUV2QiwwQkFBcUIsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNoRCxvQkFBZSxHQUFHLE1BQU0sRUFBd0IsQ0FBQztRQU94RCxNQUFNLENBQUMsR0FBRyxFQUFFO1lBQ1YsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7WUFDckQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLE1BQU0sQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLENBQUM7UUFDdEUsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsUUFBUTtRQUNOLHNEQUFzRDtRQUN0RCxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUM7UUFDeEMsd0NBQXdDO1FBQ3hDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUMxRCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLGFBQWEsQ0FBQyxLQUFvQjtRQUN0QyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGNBQWMsQ0FBQyxPQUFnQixFQUFFLEtBQW9CO1FBQ25ELElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNiLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDdkIsT0FBTztRQUNULENBQUM7UUFDRCxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGdCQUFnQixDQUFDLEtBQW9CO1FBQ25DLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsTUFBTSxLQUFLLEtBQUssQ0FBQyxNQUFNO1lBQ3BELElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILHFCQUFxQixDQUFDLEtBQW9CO1FBQ3hDLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUM7WUFDdkMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7SUFDbEQsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsbUJBQW1CLENBQUMsSUFBaUI7UUFDbkMsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLFFBQVE7WUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUMxRCxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssTUFBTTtZQUFFLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO0lBQzFELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILElBQUksdUJBQXVCO1FBQ3pCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxDQUFDO0lBQ3hFLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILFdBQVcsQ0FBQyxLQUFvQjtRQUM5QixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQywwQkFBMEIsRUFBRTtZQUM3RCxFQUFFLEVBQUUscUJBQXFCO1lBQ3pCLFFBQVEsRUFBRSxPQUFPO1NBQ2xCLENBQUMsQ0FBQztRQUNILFNBQVMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFnQixFQUFFLEVBQUU7WUFDakUsSUFBSSxPQUFPLEVBQUUsQ0FBQztnQkFDWixJQUFJLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUM7cUJBQ2pDLElBQUksQ0FBQyxHQUFHLEVBQUU7b0JBQ1QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztvQkFDdkIsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUM7d0JBQ3BELElBQUksQ0FBQyxZQUFZLEdBQUcsU0FBUyxDQUFDO29CQUNoQyxDQUFDO2dCQUNILENBQUMsQ0FBQztxQkFDRCxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztZQUNqRCxDQUFDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSCxZQUFZLENBQUMsU0FBbUIsRUFBRSxLQUFhO1FBQzdDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQztRQUM3QixPQUFPLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsY0FBYyxDQUFDLElBQVk7UUFDekIsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDNUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7UUFDeEIsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRTtZQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDeEQsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxJQUFZO1FBQ25DLE1BQU0sVUFBVSxHQUFxQixJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN0RSxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQzthQUN6QyxJQUFJLENBQUMsS0FBSyxFQUFFLEVBQUMsS0FBSyxFQUFFLFFBQVEsRUFBQyxFQUFFLEVBQUU7WUFDaEMsTUFBTSxRQUFRLEdBQWtCO2dCQUM5QixHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUM7Z0JBQ2pELEdBQUcsQ0FBQyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7YUFDbEUsQ0FBQztZQUNGLE9BQU8sUUFBUSxDQUFDO1FBQ2xCLENBQUMsQ0FBQzthQUNELEtBQUssQ0FBQyxDQUFDLEtBQW9CLEVBQUUsRUFBRTtZQUM5QixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztZQUNuQixPQUFPLElBQUksT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3RDLENBQUMsQ0FBQyxDQUFDO0lBQ1QsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsTUFBTSxDQUFDLE9BQXNCLElBQUk7UUFDL0IsSUFBSSxPQUF5QixDQUFDO1FBQzlCLElBQUksSUFBSTtZQUFFLE9BQU8sR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQzs7WUFDaEQsT0FBTyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUU1RCxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQzthQUM3QyxJQUFJLENBQUMsS0FBSyxFQUFFLEVBQUMsS0FBSyxFQUFFLFFBQVEsRUFBQyxFQUFFLEVBQUUsQ0FBQztZQUNqQyxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUM7WUFDakQsR0FBRyxDQUFDLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztTQUNsRSxDQUFDLENBQUM7SUFDVCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsZUFBZTtRQUNiLE1BQU0saUJBQWlCLEdBQTRCO1lBQ2pELFVBQVUsRUFBRSxFQUFFO1lBQ2QsSUFBSSxFQUFFLElBQUksQ0FBQyxXQUFXO1NBQ3ZCLENBQUM7UUFDRixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyx3QkFBd0IsRUFBRTtZQUMzRCxFQUFFLEVBQUUsMEJBQTBCO1lBQzlCLEtBQUssRUFBRSxPQUFPO1lBQ2QsSUFBSSxFQUFFLGlCQUFpQjtTQUN4QixDQUFDLENBQUM7UUFDSCxTQUFTLENBQUMsV0FBVyxFQUFFO2FBQ2xCLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQzthQUNiLE9BQU8sQ0FBQyxDQUFDLFFBQXNDLEVBQUUsRUFBRTtZQUNsRCxJQUFJLFFBQVEsQ0FBQyxVQUFVLEVBQUUsQ0FBQztnQkFDeEIsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO29CQUMvQixHQUFHLElBQUksQ0FBQyxXQUFXLElBQUksUUFBUSxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDO2dCQUNuRSxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzVCLENBQUM7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNULENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILEtBQUssQ0FBQyxXQUFXLENBQUMsS0FBZ0I7UUFDaEMsSUFBSSxDQUFDLEtBQUs7WUFBRSxPQUFPO1FBRW5CLHdDQUF3QztRQUN4QyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDOUQsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsd0NBQXdDLENBQUMsQ0FBQztZQUN6RCxPQUFPO1FBQ1QsQ0FBQztRQUVELE1BQU0sYUFBYSxHQUFtQixFQUFFLENBQUM7UUFFekMsS0FBSyxNQUFNLElBQUksSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7WUFDckMsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGNBQWM7aUJBQzlCLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7WUFFaEQsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDO2lCQUM5QyxJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7aUJBQ2hELEtBQUssQ0FBQyxDQUFDLEtBQW9CLEVBQUUsRUFBRTtnQkFDOUIsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNsRCxDQUFDLENBQUMsQ0FBQztRQUNULENBQUM7UUFFRCxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU07WUFBRSxPQUFPO1FBRWxDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzlCLHNDQUFzQztRQUN0QyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLGFBQWEsQ0FBQyxNQUFNLElBQUksYUFBYSxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsYUFBYSxDQUFDLENBQUM7SUFDckgsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsYUFBYSxDQUFDLE1BQWE7UUFDL0IsTUFBTSxLQUFLLEdBQ1IsTUFBTSxDQUFDLE1BQTJCLENBQUMsS0FBaUIsQ0FBQztRQUN4RCxNQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsaUJBQWlCLENBQUMsS0FBb0IsRUFBRSxRQUFnQjtRQUN0RCxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FDYixLQUFLLENBQUMsSUFBSSxLQUFLLHNCQUFzQixDQUFDLENBQUM7WUFDckMsc0NBQXNDLENBQUMsQ0FBQztZQUN4QywwQkFBMEIsUUFBUSxHQUFHLEVBQ3ZDLEtBQUssQ0FDTixDQUFDO0lBQ0osQ0FBQzs4R0E1U1Usb0JBQW9CO2tHQUFwQixvQkFBb0Isb09DekRqQyw2NkxBMElBLDZxRERoR0ksU0FBUyw2Q0FDVCxlQUFlLHdVQUNmLGFBQWEsbUxBQ2IsY0FBYywybENBQ2QsaUJBQWlCLDhXQUNqQix3QkFBd0IsK0ZBQ3hCLGVBQWUsK0NBQ2YsUUFBUSw2Q0FDUiwyQkFBMkIsNkdBQzNCLHFCQUFxQix3SEFDckIsdUJBQXVCLHFGQUN2QixPQUFPOzsyRkFJRSxvQkFBb0I7a0JBckJoQyxTQUFTOytCQUNFLG1CQUFtQixjQUdqQixJQUFJLFdBQ1A7d0JBQ1AsU0FBUzt3QkFDVCxlQUFlO3dCQUNmLGFBQWE7d0JBQ2IsY0FBYzt3QkFDZCxpQkFBaUI7d0JBQ2pCLHdCQUF3Qjt3QkFDeEIsZUFBZTt3QkFDZixRQUFRO3dCQUNSLDJCQUEyQjt3QkFDM0IscUJBQXFCO3dCQUNyQix1QkFBdUI7d0JBQ3ZCLE9BQU87cUJBQ1IsbUJBQ2dCLHVCQUF1QixDQUFDLE1BQU07c0pBeUI3QyxTQUFTO3NCQURWLEtBQUs7Z0JBT0osWUFBWTtzQkFEYixLQUFLO2dCQU9KLGVBQWU7c0JBRGhCLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBlZmZlY3QsIElucHV0LCBPbkluaXQsIG91dHB1dCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0ZpcmViYXNlU3RvcmFnZVNlcnZpY2V9IGZyb20gJy4vc2VydmljZXMvZmlyZWJhc2Utc3RvcmFnZS5zZXJ2aWNlJztcbmltcG9ydCB7U3RvcmFnZVJlZmVyZW5jZSwgVXBsb2FkUmVzdWx0fSBmcm9tICdAYW5ndWxhci9maXJlL3N0b3JhZ2UnO1xuaW1wb3J0IHtGaXJlYmFzZUVycm9yfSBmcm9tICdAYW5ndWxhci9maXJlL2FwcC9maXJlYmFzZSc7XG5pbXBvcnQge01hdERpYWxvZ30gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvZGlhbG9nJztcbmltcG9ydCB7XG4gIE5ld0ZvbGRlckRpYWxvZ0Nsb3NlQ29udHJhY3QsXG4gIE5ld0ZvbGRlckRpYWxvZ0NvbXBvbmVudCwgTmV3Rm9sZGVyRGlhbG9nQ29udHJhY3QsXG59IGZyb20gJy4vY29tcG9uZW50cy9uZXctZm9sZGVyLWRpYWxvZy9uZXctZm9sZGVyLWRpYWxvZy5jb21wb25lbnQnO1xuaW1wb3J0IHtTdG9yYWdlSXRlbSwgU3RvcmFnZUZpbGV9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQge1NlbGVjdGlvbk1vZGVsfSBmcm9tICdAYW5ndWxhci9jZGsvY29sbGVjdGlvbnMnO1xuaW1wb3J0IHtcbiAgRGVsZXRlRmlsZXNEaWFsb2dDb21wb25lbnQsXG59IGZyb20gJy4vY29tcG9uZW50cy9kZWxldGUtZmlsZXMtZGlhbG9nL2RlbGV0ZS1maWxlcy1kaWFsb2cuY29tcG9uZW50JztcbmltcG9ydCB7QXN5bmNQaXBlLCBEYXRlUGlwZSwgTmdDbGFzc30gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7TWF0QnV0dG9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9idXR0b24nO1xuaW1wb3J0IHtNYXRJY29uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9pY29uJztcbmltcG9ydCB7TWF0VGFibGVNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL3RhYmxlJztcbmltcG9ydCB7TWF0Q2hlY2tib3hNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL2NoZWNrYm94JztcbmltcG9ydCB7XG4gIFN0b3JhZ2VJdGVtSWNvbkNvbXBvbmVudCxcbn0gZnJvbSAnLi9jb21wb25lbnRzL3N0b3JhZ2UtaXRlbS1pY29uL3N0b3JhZ2UtaXRlbS1pY29uLmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1hdEJ5dGVzUGlwZX0gZnJvbSAnLi9waXBlcy9mb3JtYXQtYnl0ZXMucGlwZSc7XG5pbXBvcnQge1xuICBTdG9yYWdlRmlsZVByZXZpZXdDb21wb25lbnQsXG59IGZyb20gJy4vY29tcG9uZW50cy9zdG9yYWdlLWZpbGUtcHJldmlldy9zdG9yYWdlLWZpbGUtcHJldmlldy5jb21wb25lbnQnO1xuaW1wb3J0IHtGaWxlRHJvcHpvbmVEaXJlY3RpdmV9IGZyb20gJy4vZGlyZWN0aXZlcy9maWxlLWRyb3B6b25lLmRpcmVjdGl2ZSc7XG5pbXBvcnQge1xuICBMb2FkaW5nT3JFcnJvckNvbXBvbmVudCxcbn0gZnJvbSAnLi9jb21wb25lbnRzL2xvYWRpbmctb3ItZXJyb3IvbG9hZGluZy1vci1lcnJvci5jb21wb25lbnQnO1xuaW1wb3J0IHtDb25zb2xlTG9nZ2VyU2VydmljZX0gZnJvbSAnLi9zZXJ2aWNlcy9jb25zb2xlLWxvZ2dlci5zZXJ2aWNlJztcbmltcG9ydCB7Zmlyc3R9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHt0b1NpZ25hbH0gZnJvbSAnQGFuZ3VsYXIvY29yZS9yeGpzLWludGVyb3AnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdhbm9uLWZpbGUtbWFuYWdlcicsXG4gIHRlbXBsYXRlVXJsOiAnLi9maWxlLW1hbmFnZXIuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybDogJy4vZmlsZS1tYW5hZ2VyLmNvbXBvbmVudC5zY3NzJyxcbiAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgaW1wb3J0czogW1xuICAgIEFzeW5jUGlwZSxcbiAgICBNYXRCdXR0b25Nb2R1bGUsXG4gICAgTWF0SWNvbk1vZHVsZSxcbiAgICBNYXRUYWJsZU1vZHVsZSxcbiAgICBNYXRDaGVja2JveE1vZHVsZSxcbiAgICBTdG9yYWdlSXRlbUljb25Db21wb25lbnQsXG4gICAgRm9ybWF0Qnl0ZXNQaXBlLFxuICAgIERhdGVQaXBlLFxuICAgIFN0b3JhZ2VGaWxlUHJldmlld0NvbXBvbmVudCxcbiAgICBGaWxlRHJvcHpvbmVEaXJlY3RpdmUsXG4gICAgTG9hZGluZ09yRXJyb3JDb21wb25lbnQsXG4gICAgTmdDbGFzcyxcbiAgXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIEZpbGVNYW5hZ2VyQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgLyoqXG4gICAqIFRoZSBjb2x1bW5zIHRvIGRpc3BsYXkgaW4gdGhlIGZpbGUgbWFuYWdlbWVudCB0YWJsZS5cbiAgICovXG4gIHRhYmxlQ29sdW1uczogc3RyaW5nW10gPSBbJ2NoZWNrYm94JywgJ25hbWUnLCAnc2l6ZScsICd0eXBlJywgJ2xhc3RNb2RpZmllZCddO1xuICAvKipcbiAgICogQSBQcm9taXNlIHJlc29sdmluZyB0byBhbiBhcnJheSBvZiBTdG9yYWdlSXRlbSBvYmplY3RzIHJlcHJlc2VudGluZ1xuICAgKiB0aGUgY3VycmVudCBkaXJlY3RvcnkgY29udGVudHMsIG9yIHVuZGVmaW5lZCBpZiBhbiBlcnJvciBvY2N1cnMuXG4gICAqL1xuICBpdGVtcyQ/OiBQcm9taXNlPFN0b3JhZ2VJdGVtW10+IHwgdW5kZWZpbmVkO1xuICAvKipcbiAgICogVGhlIGN1cnJlbnQgcGF0aCB3aXRoaW4gdGhlIHN0b3JhZ2Ugc3lzdGVtLlxuICAgKi9cbiAgY3VycmVudFBhdGggPSAnJztcbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBwb3RlbnRpYWwgRmlyZWJhc2VFcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgZmlsZSBvcGVyYXRpb25zLlxuICAgKi9cbiAgZXJyb3I/OiBGaXJlYmFzZUVycm9yO1xuXG4gIC8qKlxuICAgKiBVc2VkIGZvciBtYW5hZ2luZyBtdWx0aXBsZSBpdGVtIHNlbGVjdGlvbiB3aXRoaW4gdGhlIGZpbGUgbWFuYWdlci5cbiAgICovXG4gIEBJbnB1dCgpXG4gICAgc2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvbk1vZGVsPFN0b3JhZ2VJdGVtPih0cnVlLCBbXSk7XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZmlsZSAoaWYgYW55KS5cbiAgICovXG4gIEBJbnB1dCgpXG4gICAgc2VsZWN0ZWRGaWxlOiBTdG9yYWdlRmlsZSB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogVGhlIHJvb3QgcGF0aCB3aXRoaW4gdGhlIHN0b3JhZ2Ugc3lzdGVtIHdoZXJlIHRoZSBmaWxlIG1hbmFnZXIgb3BlcmF0ZXMuXG4gICAqL1xuICBASW5wdXQoKVxuICAgIHJvb3RTdG9yYWdlUGF0aCA9ICcnO1xuXG4gIHNlbGVjdGlvbkNoYW5nZVNpZ25hbCA9IHRvU2lnbmFsKHRoaXMuc2VsZWN0aW9uLmNoYW5nZWQpO1xuICByZWFkb25seSBzZWxlY3Rpb25DaGFuZ2UgPSBvdXRwdXQ8U3RvcmFnZUl0ZW1bXSB8IG51bGw+KCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBkaWFsb2c6IE1hdERpYWxvZyxcbiAgICBwcml2YXRlIGNMb2c6IENvbnNvbGVMb2dnZXJTZXJ2aWNlLFxuICAgIHByaXZhdGUgc3RvcmFnZVNlcnZpY2U6IEZpcmViYXNlU3RvcmFnZVNlcnZpY2UsXG4gICkge1xuICAgIGVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb25DaGFuZ2UgPSB0aGlzLnNlbGVjdGlvbkNoYW5nZVNpZ25hbCgpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2UuZW1pdChzZWxlY3Rpb25DaGFuZ2U/LnNvdXJjZS5zZWxlY3RlZCB8fCBudWxsKTtcbiAgICB9KTtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIC8qKiBTZXRzIHRoZSBpbml0aWFsIHBhdGggd2l0aGluIHRoZSBzdG9yYWdlIHN5c3RlbSAqL1xuICAgIHRoaXMuY3VycmVudFBhdGggPSB0aGlzLnJvb3RTdG9yYWdlUGF0aDtcbiAgICAvKiogRmV0Y2hlcyB0aGUgaW5pdGlhbCBzdG9yYWdlIGl0ZW1zICovXG4gICAgdGhpcy5pdGVtcyQgPSB0aGlzLmdldEFsbFN0b3JhZ2VJdGVtcyh0aGlzLmN1cnJlbnRQYXRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEb3dubG9hZHMgdGhlIHByb3ZpZGVkIGZpbGVzIGJ5IHRyaWdnZXJpbmcgZG93bmxvYWQgbGlua3MuXG4gICAqIEBwYXJhbSB7U3RvcmFnZUl0ZW1bXX0gZmlsZXMgLSBUaGUgZmlsZXMgdG8gZG93bmxvYWQuXG4gICAqL1xuICBhc3luYyBkb3dubG9hZEZpbGVzKGZpbGVzOiBTdG9yYWdlSXRlbVtdKSB7XG4gICAgYXdhaXQgdGhpcy5zdG9yYWdlU2VydmljZS5vcGVuQWxsRmlsZXMoZmlsZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHNlbGVjdGlvbiBvZiBhbGwgaXRlbXMgaW4gdGhlIGZpbGUgbGlzdGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBjaGVja2VkIC0gV2hldGhlciB0byBzZWxlY3Qgb3IgZGVzZWxlY3QgYWxsIGl0ZW1zLlxuICAgKiBAcGFyYW0ge1N0b3JhZ2VJdGVtW119IGl0ZW1zIC0gVGhlIGxpc3Qgb2YgZmlsZSBpdGVtcy5cbiAgICovXG4gIHRvZ2dsZUFsbEl0ZW1zKGNoZWNrZWQ6IGJvb2xlYW4sIGl0ZW1zOiBTdG9yYWdlSXRlbVtdKSB7XG4gICAgaWYgKCFjaGVja2VkKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3QoLi4uaXRlbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhbGwgaXRlbXMgaW4gdGhlIGZpbGUgbGlzdGluZyBhcmUgY3VycmVudGx5IHNlbGVjdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0b3JhZ2VJdGVtW119IGl0ZW1zIC0gVGhlIGxpc3Qgb2YgZmlsZSBpdGVtcy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbGwgaXRlbXMgYXJlIHNlbGVjdGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBhbGxJdGVtc1NlbGVjdGVkKGl0ZW1zOiBTdG9yYWdlSXRlbVtdKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLnNlbGVjdGVkLmxlbmd0aCA9PT0gaXRlbXMubGVuZ3RoICYmXG4gICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3RlZC5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBzb21lLCBidXQgbm90IGFsbCwgaXRlbXMgaW4gdGhlIGZpbGUgbGlzdGluZyBhcmUgc2VsZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RvcmFnZUl0ZW1bXX0gaXRlbXMgLSBUaGUgbGlzdCBvZiBmaWxlIGl0ZW1zLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBzZWxlY3Rpb24gc3RhdGUgaXMgaW5kZXRlcm1pbmF0ZSwgZmFsc2VcbiAgICogb3RoZXJ3aXNlLlxuICAgKi9cbiAgYWxsSXRlbXNJbmRldGVybWluYXRlKGl0ZW1zOiBTdG9yYWdlSXRlbVtdKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLnNlbGVjdGVkLmxlbmd0aCA+IDAgJiZcbiAgICAgIHRoaXMuc2VsZWN0aW9uLnNlbGVjdGVkLmxlbmd0aCA8IGl0ZW1zLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciB3aGVuIGEgc3RvcmFnZSBpdGVtIGlzIHNlbGVjdGVkLiBVcGRhdGVzIHRoZSBuYXZpZ2F0aW9uXG4gICAqIGlmIGEgZm9sZGVyIGlzIHNlbGVjdGVkLCBvciBzZXRzIHRoZSBzZWxlY3RlZCBmaWxlIGlmIGEgZmlsZSBpcyBzZWxlY3RlZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdG9yYWdlSXRlbX0gaXRlbSAtIFRoZSBzZWxlY3RlZCBTdG9yYWdlSXRlbS5cbiAgICovXG4gIHN0b3JhZ2VJdGVtU2VsZWN0ZWQoaXRlbTogU3RvcmFnZUl0ZW0pIHtcbiAgICBpZiAoaXRlbS50eXBlID09PSAnZm9sZGVyJykgdGhpcy5zZXRTdG9yYWdlUGF0aChpdGVtLmZ1bGxQYXRoKTtcbiAgICBlbHNlIGlmIChpdGVtLnR5cGUgPT09ICdmaWxlJykgdGhpcy5zZWxlY3RlZEZpbGUgPSBpdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gaW5jbHVkZXMgYXQgbGVhc3Qgb25lIGZvbGRlci5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhIGZvbGRlciBpcyBwYXJ0IG9mIHRoZSBzZWxlY3Rpb24sIGZhbHNlXG4gICAqIG90aGVyd2lzZS5cbiAgICovXG4gIGdldCBzZWxlY3Rpb25JbmNsdWRlc0ZvbGRlcigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uc2VsZWN0ZWQuc29tZSgoaXRlbSkgPT4gaXRlbS50eXBlID09PSAnZm9sZGVyJyk7XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgYSBkaWFsb2cgdG8gY29uZmlybSBkZWxldGlvbiwgYW5kIGhhbmRsZXMgZGVsZXRpbmcgc2VsZWN0ZWQgaXRlbXNcbiAgICogaWYgY29uZmlybWVkLiBDbGVhcnMgdGhlIHNlbGVjdGlvbiBhbmQgdXBkYXRlcyB0aGUgZmlsZSBsaXN0aW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0b3JhZ2VJdGVtW119IGl0ZW1zIC0gVGhlIGl0ZW1zIHRvIGRlbGV0ZS5cbiAgICovXG4gIGRlbGV0ZUl0ZW1zKGl0ZW1zOiBTdG9yYWdlSXRlbVtdKSB7XG4gICAgY29uc3QgZGlhbG9nUmVmID0gdGhpcy5kaWFsb2cub3BlbihEZWxldGVGaWxlc0RpYWxvZ0NvbXBvbmVudCwge1xuICAgICAgaWQ6ICdkZWxldGUtZmlsZXMtZGlhbG9nJyxcbiAgICAgIG1pbldpZHRoOiAnMjUwcHgnLFxuICAgIH0pO1xuICAgIGRpYWxvZ1JlZi5hZnRlckNsb3NlZCgpLnBpcGUoZmlyc3QoKSkuZm9yRWFjaCgoY29uZmlybTogYm9vbGVhbikgPT4ge1xuICAgICAgaWYgKGNvbmZpcm0pIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlU2VydmljZS5kZWxldGVGaWxlcyhpdGVtcylcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uY2xlYXIoKTtcbiAgICAgICAgICAgICAgaWYgKGl0ZW1zLnNvbWUoKGl0ZW0pID0+IGl0ZW0gPT0gdGhpcy5zZWxlY3RlZEZpbGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEZpbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLnJlbG9hZCh0aGlzLmN1cnJlbnRQYXRoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIGJyZWFkY3J1bWItc3R5bGUgcGF0aCBzdHJpbmcgYmFzZWQgb24gdGhlIGN1cnJlbnQgcGF0aFxuICAgKiBoaXN0b3J5LiBVc2VkIGZvciBuYXZpZ2F0aW9uIGRpc3BsYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhBcnJheSAtIEFuIGFycmF5IG9mIHBhdGggc2VnbWVudHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCB1cCB0byB3aGljaCBwYXRoIHNlZ21lbnRzIHNob3VsZCBiZVxuICAgKiBpbmNsdWRlZC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgY29uc3RydWN0ZWQgcGF0aCBzdHJpbmcuXG4gICAqL1xuICBnZXRDcnVtYlBhdGgocGF0aEFycmF5OiBzdHJpbmdbXSwgaW5kZXg6IG51bWJlcik6IHN0cmluZyB7XG4gICAgcGF0aEFycmF5Lmxlbmd0aCA9IGluZGV4ICsgMTtcbiAgICByZXR1cm4gcGF0aEFycmF5LmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjdXJyZW50IHBhdGggYW5kIGZldGNoZXMgdGhlIG5ldyBmaWxlIGxpc3RpbmcuXG4gICAqIENsZWFycyBhbnkgZXhpc3Rpbmcgc2VsZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIFRoZSBuZXcgc3RvcmFnZSBwYXRoLlxuICAgKi9cbiAgc2V0U3RvcmFnZVBhdGgocGF0aDogc3RyaW5nKSB7XG4gICAgdGhpcy5pdGVtcyQgPSB0aGlzLmdldEFsbFN0b3JhZ2VJdGVtcyhwYXRoKTtcbiAgICB0aGlzLmN1cnJlbnRQYXRoID0gcGF0aDtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb24uaGFzVmFsdWUoKSkgdGhpcy5zZWxlY3Rpb24uY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYW5kIHByb2Nlc3NlcyBhbGwgaXRlbXMgd2l0aGluIGEgZ2l2ZW4gc3RvcmFnZSBwYXRoLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIFRoZSBzdG9yYWdlIHBhdGggdG8gbGlzdC5cbiAgICogQHJldHVybiB7UHJvbWlzZTxTdG9yYWdlSXRlbVtdPn0gQSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgaXRlbXMsXG4gICAqIG9yIHVuZGVmaW5lZCBpbiBjYXNlIG9mIGVycm9yLlxuICAgKi9cbiAgYXN5bmMgZ2V0QWxsU3RvcmFnZUl0ZW1zKHBhdGg6IHN0cmluZyk6IFByb21pc2U8U3RvcmFnZUl0ZW1bXT4ge1xuICAgIGNvbnN0IHN0b3JhZ2VSZWY6IFN0b3JhZ2VSZWZlcmVuY2UgPSB0aGlzLnN0b3JhZ2VTZXJ2aWNlLmdldFJlZihwYXRoKTtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlU2VydmljZS5saXN0QWxsKHN0b3JhZ2VSZWYpXG4gICAgICAgIC50aGVuKGFzeW5jICh7aXRlbXMsIHByZWZpeGVzfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGFsbEl0ZW1zOiBTdG9yYWdlSXRlbVtdID0gW1xuICAgICAgICAgICAgLi4ucHJlZml4ZXMubWFwKHRoaXMuc3RvcmFnZVNlcnZpY2UuaW1wb3J0Rm9sZGVyKSxcbiAgICAgICAgICAgIC4uLihhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAodGhpcy5zdG9yYWdlU2VydmljZS5pbXBvcnRGaWxlKSkpLFxuICAgICAgICAgIF07XG4gICAgICAgICAgcmV0dXJuIGFsbEl0ZW1zO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycm9yOiBGaXJlYmFzZUVycm9yKSA9PiB7XG4gICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxvYWRzIHRoZSBmaWxlIGFuZCBmb2xkZXIgbGlzdGluZyB3aXRoaW4gdGhlIGN1cnJlbnQgb3Igc3BlY2lmaWVkIHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gcGF0aCAtIE9wdGlvbmFsLiBUaGUgcGF0aCB0byByZWxvYWQuIElmIG51bGwsXG4gICAqIHRoZSBjdXJyZW50IHBhdGggaXMgdXNlZC5cbiAgICovXG4gIHJlbG9hZChwYXRoOiBzdHJpbmcgfCBudWxsID0gbnVsbCkge1xuICAgIGxldCBwYXRoUmVmOiBTdG9yYWdlUmVmZXJlbmNlO1xuICAgIGlmIChwYXRoKSBwYXRoUmVmID0gdGhpcy5zdG9yYWdlU2VydmljZS5nZXRSZWYocGF0aCk7XG4gICAgZWxzZSBwYXRoUmVmID0gdGhpcy5zdG9yYWdlU2VydmljZS5nZXRSZWYodGhpcy5jdXJyZW50UGF0aCk7XG5cbiAgICB0aGlzLml0ZW1zJCA9IHRoaXMuc3RvcmFnZVNlcnZpY2UubGlzdEFsbChwYXRoUmVmKVxuICAgICAgICAudGhlbihhc3luYyAoe2l0ZW1zLCBwcmVmaXhlc30pID0+IFtcbiAgICAgICAgICAuLi5wcmVmaXhlcy5tYXAodGhpcy5zdG9yYWdlU2VydmljZS5pbXBvcnRGb2xkZXIpLFxuICAgICAgICAgIC4uLihhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAodGhpcy5zdG9yYWdlU2VydmljZS5pbXBvcnRGaWxlKSkpLFxuICAgICAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyBhIGRpYWxvZyB0byBjcmVhdGUgYSBuZXcgZm9sZGVyIGFuZCB1cGRhdGVzIGZvbGRlciBsaXN0aW5nXG4gICAqIGlmIHN1Y2Nlc3NmdWwuXG4gICAqL1xuICBjcmVhdGVOZXdGb2xkZXIoKSB7XG4gICAgY29uc3QgbmV3Rm9sZGVyQ29udHJhY3Q6IE5ld0ZvbGRlckRpYWxvZ0NvbnRyYWN0ID0ge1xuICAgICAgZm9sZGVyTmFtZTogJycsXG4gICAgICBwYXRoOiB0aGlzLmN1cnJlbnRQYXRoLFxuICAgIH07XG4gICAgY29uc3QgZGlhbG9nUmVmID0gdGhpcy5kaWFsb2cub3BlbihOZXdGb2xkZXJEaWFsb2dDb21wb25lbnQsIHtcbiAgICAgIGlkOiAnY3JlYXRlLW5ldy1mb2xkZXItZGlhbG9nJyxcbiAgICAgIHdpZHRoOiAnMjUwcHgnLFxuICAgICAgZGF0YTogbmV3Rm9sZGVyQ29udHJhY3QsXG4gICAgfSk7XG4gICAgZGlhbG9nUmVmLmFmdGVyQ2xvc2VkKClcbiAgICAgICAgLnBpcGUoZmlyc3QoKSlcbiAgICAgICAgLmZvckVhY2goKGNvbnRyYWN0OiBOZXdGb2xkZXJEaWFsb2dDbG9zZUNvbnRyYWN0KSA9PiB7XG4gICAgICAgICAgaWYgKGNvbnRyYWN0LmZvbGRlck5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLmN1cnJlbnRQYXRoID9cbiAgICAgICAgICAgIGAke3RoaXMuY3VycmVudFBhdGh9LyR7Y29udHJhY3QuZm9sZGVyTmFtZX1gIDogY29udHJhY3QuZm9sZGVyTmFtZTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RvcmFnZVBhdGgocGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGZpbGUgdXBsb2FkIGxvZ2ljLCBpbmNsdWRpbmcgdmFsaWRhdGlvbiBhbmQgdXBkYXRpbmcgdGhlXG4gICAqIGZpbGUgbGlzdGluZyB1cG9uIHN1Y2Nlc3NmdWwgdXBsb2FkLiBMb2dzIGVycm9ycyBpZiBlbmNvdW50ZXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHtGaWxlTGlzdH0gZmlsZXMgLSBBbiBvcHRpb25hbCBGaWxlTGlzdCBvZiBmaWxlcyB0byB1cGxvYWQuXG4gICAqL1xuICBhc3luYyB1cGxvYWRJdGVtcyhmaWxlcz86IEZpbGVMaXN0KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFmaWxlcykgcmV0dXJuO1xuXG4gICAgLy8gcHJldmVudCBmaWxlIG5hbWVzIHRvIGhhdmUgXCIsXCIoY29tbWEpXG4gICAgaWYgKEFycmF5LmZyb20oZmlsZXMpLnNvbWUoKGZpbGUpID0+IGZpbGUubmFtZS5pbmNsdWRlcygnLCcpKSkge1xuICAgICAgdGhpcy5jTG9nLndhcm4oYEZpbGUgbmFtZXMgY2Fubm90IGluY2x1ZGUgYSBcIixcIihjb21tYSlgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB1cGxvYWRlZEZpbGVzOiBVcGxvYWRSZXN1bHRbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBmaWxlIG9mIEFycmF5LmZyb20oZmlsZXMpKSB7XG4gICAgICBjb25zdCBmaWxlUmVmID0gdGhpcy5zdG9yYWdlU2VydmljZVxuICAgICAgICAgIC5nZXRSZWYoYCR7dGhpcy5jdXJyZW50UGF0aH0vJHtmaWxlLm5hbWV9YCk7XG5cbiAgICAgIGF3YWl0IHRoaXMuc3RvcmFnZVNlcnZpY2UudXBsb2FkRmlsZShmaWxlUmVmLCBmaWxlKVxuICAgICAgICAgIC50aGVuKChzbmFwc2hvdCkgPT4gdXBsb2FkZWRGaWxlcy5wdXNoKHNuYXBzaG90KSlcbiAgICAgICAgICAuY2F0Y2goKGVycm9yOiBGaXJlYmFzZUVycm9yKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVVcGxvYWRFcnJvcihlcnJvciwgZmlsZS5uYW1lKTtcbiAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXVwbG9hZGVkRmlsZXMubGVuZ3RoKSByZXR1cm47XG5cbiAgICB0aGlzLnJlbG9hZCh0aGlzLmN1cnJlbnRQYXRoKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlbiAqL1xuICAgIHRoaXMuY0xvZy5pbmZvKGBVcGxvYWRlZCAke3VwbG9hZGVkRmlsZXMubGVuZ3RofSAke3VwbG9hZGVkRmlsZXMubGVuZ3RoID09PSAxID8gJ2ZpbGUnIDogJ2ZpbGVzJ31gLCB1cGxvYWRlZEZpbGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBmaWxlIGlucHV0IGNoYW5nZS4gVHJpZ2dlcnMgdGhlIHVwbG9hZCBwcm9jZXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSAkZXZlbnQgLSBUaGUgZmlsZSBpbnB1dCBjaGFuZ2UgZXZlbnQuXG4gICAqL1xuICBhc3luYyBvbkZpbGVzU2VsZWN0KCRldmVudDogRXZlbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBmaWxlczogRmlsZUxpc3QgPVxuICAgICAgKCRldmVudC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkuZmlsZXMgYXMgRmlsZUxpc3Q7XG4gICAgYXdhaXQgdGhpcy51cGxvYWRJdGVtcyhmaWxlcyk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBsb2dnaW5nIG9mIGVycm9ycyBkdXJpbmcgdGhlIGZpbGUgdXBsb2FkIHByb2Nlc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7RmlyZWJhc2VFcnJvcn0gZXJyb3IgLSBUaGUgRmlyZWJhc2UgZXJyb3Igb2JqZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0aGF0IGZhaWxlZCB0byB1cGxvYWQuXG4gICAqL1xuICBoYW5kbGVVcGxvYWRFcnJvcihlcnJvcjogRmlyZWJhc2VFcnJvciwgZmlsZW5hbWU6IHN0cmluZykge1xuICAgIHRoaXMuY0xvZy5lcnJvcihcbiAgICAgIGVycm9yLmNvZGUgPT09ICdzdG9yYWdlL3VuYXV0aG9yaXplZCcgP1xuICAgICAgICAnWW91IGRvIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gdXBsb2FkJyA6XG4gICAgICAgIGBFcnJvciB1cGxvYWRpbmcgZmlsZTogJyR7ZmlsZW5hbWV9J2AsXG4gICAgICBlcnJvcixcbiAgICApO1xuICB9XG59XG4iLCJAaWYgKGl0ZW1zJCB8IGFzeW5jOyBhcyBpdGVtcykge1xuICA8ZGl2IGNsYXNzPVwiY2FyZFwiPlxuICAgIDxpbnB1dCAjaW5wdXRVcGxvYWQgbXVsdGlwbGUgY2xhc3M9XCJpbnB1dFVwbG9hZFwiXG4gICAgICAgICAgIHR5cGU9XCJmaWxlXCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgICAgIChjaGFuZ2UpPVwib25GaWxlc1NlbGVjdCgkZXZlbnQpXCIgLz5cbiAgICAgXG4gICAgQGlmIChzZWxlY3Rpb24uaXNFbXB0eSgpKSB7XG4gICAgICA8aGVhZGVyIGNsYXNzPVwiaGVhZGVyXCI+XG4gICAgICAgIDwhLS0gQ3J1bWJzIC0tPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImNydW1ic1wiPlxuICAgICAgICAgIDxidXR0b24gbWF0LWljb24tYnV0dG9uIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImN1cnJlbnRQYXRoPT09cm9vdFN0b3JhZ2VQYXRoXCJcbiAgICAgICAgICAgICAgICAgIChjbGljayk9XCJzZXRTdG9yYWdlUGF0aChyb290U3RvcmFnZVBhdGgpXCI+XG4gICAgICAgICAgICA8bWF0LWljb24gZm9udEljb249XCJob21lXCIgLz5cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgXG4gICAgICAgICAgQGZvciAoY3J1bWIgb2YgY3VycmVudFBhdGguc3BsaXQoJy8nKTsgdHJhY2sgY3J1bWI7bGV0IGk9JGluZGV4OyBsZXQgbGFzdD0kbGFzdCkge1xuICAgICAgICAgICAgQGlmIChjcnVtYiAhPT0gcm9vdFN0b3JhZ2VQYXRoKSB7XG4gICAgICAgICAgICAgIEBpZiAoY3VycmVudFBhdGghPT1yb290U3RvcmFnZVBhdGgpIHtcbiAgICAgICAgICAgICAgICA8bWF0LWljb24gY2xhc3M9XCJvdmVyZmxvdy12aXNpYmxlXCIgZm9udEljb249XCJjaGV2cm9uX3JpZ2h0XCIgLz5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA8YnV0dG9uIG1hdC1idXR0b24gdHlwZT1cImJ1dHRvblwiIFtkaXNhYmxlZF09XCJsYXN0XCJcbiAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwic2V0U3RvcmFnZVBhdGgoZ2V0Q3J1bWJQYXRoKGN1cnJlbnRQYXRoLnNwbGl0KCcvJyksIGkpKVwiPlxuICAgICAgICAgICAgICB7e2NydW1ifX1cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgPC9zcGFuPlxuXG4gICAgICAgIDxidXR0b24gbWF0LWljb24tYnV0dG9uIHR5cGU9XCJidXR0b25cIiAoY2xpY2spPVwicmVsb2FkKClcIj5cbiAgICAgICAgICA8bWF0LWljb24gZm9udEljb249XCJyZWZyZXNoXCIgLz5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gbWF0LWljb24tYnV0dG9uIHR5cGU9XCJidXR0b25cIiAoY2xpY2spPVwiY3JlYXRlTmV3Rm9sZGVyKClcIj5cbiAgICAgICAgICA8bWF0LWljb24gZm9udEljb249XCJjcmVhdGVfbmV3X2ZvbGRlclwiIC8+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxidXR0b24gbWF0LWZsYXQtYnV0dG9uIHR5cGU9XCJidXR0b25cIiBjb2xvcj1cInByaW1hcnlcIlxuICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cImlucHV0VXBsb2FkLmNsaWNrKClcIj5VcGxvYWQ8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2hlYWRlcj5cbiAgICB9IEBlbHNlIHtcbiAgICAgIDxoZWFkZXIgY2xhc3M9XCJoZWFkZXIgaXRlbXMtc2VsZWN0ZWRcIj5cbiAgICAgICAgPGJ1dHRvbiBtYXQtaWNvbi1idXR0b24gdHlwZT1cImJ1dHRvblwiIChjbGljayk9XCJzZWxlY3Rpb24uY2xlYXIoKVwiPlxuICAgICAgICAgIDxtYXQtaWNvbiBmb250SWNvbj1cImNsb3NlXCIgLz5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxzcGFuPnt7c2VsZWN0aW9uLnNlbGVjdGVkLmxlbmd0aH19IHt7c2VsZWN0aW9uLnNlbGVjdGVkLmxlbmd0aCA9PT0gMSA/ICdpdGVtJyA6ICdpdGVtcyd9fTwvc3Bhbj5cbiAgICAgICAgIFxuICAgICAgICA8YnV0dG9uIG1hdC1yYWlzZWQtYnV0dG9uIHR5cGU9XCJidXR0b25cIiBjb2xvcj1cImFjY2VudFwiIFtkaXNhYmxlZF09XCJzZWxlY3Rpb25JbmNsdWRlc0ZvbGRlclwiXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cImRvd25sb2FkRmlsZXMoc2VsZWN0aW9uLnNlbGVjdGVkKVwiPkRvd25sb2FkIGZpbGVzPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gbWF0LXN0cm9rZWQtYnV0dG9uIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgIChjbGljayk9XCJkZWxldGVJdGVtcyhzZWxlY3Rpb24uc2VsZWN0ZWQpXCI+RGVsZXRlPC9idXR0b24+XG4gICAgICA8L2hlYWRlcj5cbiAgICB9XG5cbiAgICA8ZGl2IGNsYXNzPVwiY29udGVudFwiPlxuICAgICAgPGRpdiBjbGFzcz1cInRhYmxlLXNpZGViYXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRhYmxlLXdyYXBwZXJcIiBbbmdDbGFzc109XCJ7J2dyaWQtY29sdW1uLWVuZC1zcGFuLTgnOiBzZWxlY3RlZEZpbGV9XCI+XG4gICAgICAgICAgPHRhYmxlIG1hdC10YWJsZSBbZGF0YVNvdXJjZV09XCJpdGVtc1wiPlxuICAgICAgICAgICAgPCEtLSBDaGVja2JveCBDb2x1bW4gLS0+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyIG1hdENvbHVtbkRlZj1cImNoZWNrYm94XCI+XG4gICAgICAgICAgICAgIDx0aCAqbWF0SGVhZGVyQ2VsbERlZiBtYXQtaGVhZGVyLWNlbGwgY2xhc3M9XCJjaGVja2JveC1jb2x1bW5cIj5cbiAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPG1hdC1jaGVja2JveCBuYW1lPVwic2VsZWN0LWFsbFwiIFtjaGVja2VkXT1cImFsbEl0ZW1zU2VsZWN0ZWQoaXRlbXMpXCIgW2luZGV0ZXJtaW5hdGVdPVwiYWxsSXRlbXNJbmRldGVybWluYXRlKGl0ZW1zKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiaXRlbXMubGVuZ3RoID09PSAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjaGFuZ2UpPVwidG9nZ2xlQWxsSXRlbXMoJGV2ZW50LmNoZWNrZWQsIGl0ZW1zKVwiIC8+XG4gICAgICAgICAgICAgIDwvdGg+XG4gICAgICAgICAgICAgIDx0ZCAqbWF0Q2VsbERlZj1cImxldCBpdGVtXCIgbWF0LWNlbGwgY2xhc3M9XCJjaGVja2JveC1jb2x1bW5cIj5cbiAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPG1hdC1jaGVja2JveCBbY2hlY2tlZF09XCJzZWxlY3Rpb24uaXNTZWxlY3RlZChpdGVtKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwiJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjaGFuZ2UpPVwic2VsZWN0aW9uLnRvZ2dsZShpdGVtKVwiIC8+XG4gICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICAgICAgPCEtLSBOYW1lIENvbHVtbiAtLT5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgbWF0Q29sdW1uRGVmPVwibmFtZVwiPlxuICAgICAgICAgICAgICA8dGggKm1hdEhlYWRlckNlbGxEZWYgbWF0LWhlYWRlci1jZWxsPiBOYW1lIDwvdGg+XG4gICAgICAgICAgICAgIDx0ZCAqbWF0Q2VsbERlZj1cImxldCBpdGVtXCIgbWF0LWNlbGwgY2xhc3M9XCJuYW1lLWNvbHVtblwiPlxuICAgICAgICAgICAgICAgIDxhbm9uLXN0b3JhZ2UtaXRlbS1pY29uIFt0eXBlXT1cIml0ZW0udHlwZVwiIFtjb250ZW50VHlwZV09XCJpdGVtLmNvbnRlbnRUeXBlXCIgLz5cbiAgICAgICAgICAgICAgICA8c3Bhbj57e2l0ZW0ubmFtZX19PC9zcGFuPlxuICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgICAgIDwhLS0gU2l6ZSBDb2x1bW4gLS0+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyIG1hdENvbHVtbkRlZj1cInNpemVcIj5cbiAgICAgICAgICAgICAgPHRoICptYXRIZWFkZXJDZWxsRGVmIG1hdC1oZWFkZXItY2VsbD4gU2l6ZSA8L3RoPlxuICAgICAgICAgICAgICA8dGQgKm1hdENlbGxEZWY9XCJsZXQgaXRlbVwiIG1hdC1jZWxsPlxuICAgICAgICAgICAgICAgIHt7aXRlbS50eXBlID09PSAnZm9sZGVyJyA/ICcmbWRhc2g7JyA6IGl0ZW0uc2l6ZSB8IGZvcm1hdEJ5dGVzfX1cbiAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgICAgICA8IS0tIFR5cGUgQ29sdW1uIC0tPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBtYXRDb2x1bW5EZWY9XCJ0eXBlXCI+XG4gICAgICAgICAgICAgIDx0aCAqbWF0SGVhZGVyQ2VsbERlZiBtYXQtaGVhZGVyLWNlbGw+IFR5cGUgPC90aD5cbiAgICAgICAgICAgICAgPHRkICptYXRDZWxsRGVmPVwibGV0IGl0ZW1cIiBtYXQtY2VsbD5cbiAgICAgICAgICAgICAgICB7e2l0ZW0udHlwZSA9PT0gJ2ZvbGRlcicgPyAnRm9sZGVyJyA6IGl0ZW0uY29udGVudFR5cGV9fVxuICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgICAgIDwhLS0gTGFzdCBNb2RpZmllZCBDb2x1bW4gLS0+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyIG1hdENvbHVtbkRlZj1cImxhc3RNb2RpZmllZFwiPlxuICAgICAgICAgICAgICA8dGggKm1hdEhlYWRlckNlbGxEZWYgbWF0LWhlYWRlci1jZWxsPiBMYXN0IE1vZGlmaWVkIDwvdGg+XG4gICAgICAgICAgICAgIDx0ZCAqbWF0Q2VsbERlZj1cImxldCBpdGVtXCIgbWF0LWNlbGw+XG4gICAgICAgICAgICAgICAge3tpdGVtLnR5cGUgPT09ICdmb2xkZXInID8gJyZtZGFzaDsnIDogaXRlbS51cGRhdGVkIHwgZGF0ZX19XG4gICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICAgICAgPHRyICptYXRIZWFkZXJSb3dEZWY9XCJ0YWJsZUNvbHVtbnM7IHN0aWNreTogdHJ1ZVwiIG1hdC1oZWFkZXItcm93PjwvdHI+XG4gICAgICAgICAgICA8dHIgKm1hdFJvd0RlZj1cImxldCBpdGVtOyBjb2x1bW5zOiB0YWJsZUNvbHVtbnM7XCIgbWF0LXJvd1xuICAgICAgICAgICAgICAgIFtjbGFzcy5zZWxlY3RlZF09XCJzZWxlY3RlZEZpbGUgPT09IGl0ZW1cIlxuICAgICAgICAgICAgICAgIChjbGljayk9XCJzdG9yYWdlSXRlbVNlbGVjdGVkKGl0ZW0pXCI+PC90cj5cblxuICAgICAgICAgICAgPHRyICptYXROb0RhdGFSb3cgY2xhc3M9XCJtYXQtcm93XCI+XG4gICAgICAgICAgICAgIDx0ZCBjbGFzcz1cIm1hdC1jZWxsXCIgW2F0dHIuY29sc3Bhbl09XCJ0YWJsZUNvbHVtbnMubGVuZ3RoXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBhbm9uRmlsZURyb3B6b25lIGNsYXNzPVwiZW1wdHktZm9sZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgIGhvdmVyQ2xhc3M9XCJob3ZlcmluZ1wiIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwiaW5wdXRVcGxvYWQuY2xpY2soKVwiXG4gICAgICAgICAgICAgICAgICAgICAoa2V5dXApPVwiaW5wdXRVcGxvYWQuY2xpY2soKVwiXG4gICAgICAgICAgICAgICAgICAgICAoZHJvcHBlZCk9XCJ1cGxvYWRJdGVtcygkZXZlbnQpXCI+XG4gICAgICAgICAgICAgICAgICA8ZGl2Pk5vIGZpbGVzIGZvdW5kPC9kaXY+XG4gICAgICAgICAgICAgICAgICA8ZGl2PkRyYWcgYW5kIGRyb3AgZmlsZXMgdG8gdXBsb2FkPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8L3RyPlxuICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIEBpZiAoc2VsZWN0ZWRGaWxlKSB7XG4gICAgICAgICAgPGFzaWRlIGNsYXNzPVwic2lkZWJhciBncmlkLWNvbHVtbi1lbmQtc3Bhbi00XCI+XG4gICAgICAgICAgICA8YW5vbi1zdG9yYWdlLWZpbGUtcHJldmlldyBbaXRlbV09XCJzZWxlY3RlZEZpbGVcIiAoX2Nsb3NlKT1cInNlbGVjdGVkRmlsZSA9IHVuZGVmaW5lZFwiIC8+XG4gICAgICAgICAgPC9hc2lkZT5cbiAgICAgICAgfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxufSBAZWxzZSB7XG4gIDxhbm9uLWxvYWRpbmctb3ItZXJyb3IgW2Vycm9yXT1cImVycm9yXCIgLz5cbn1cbiJdfQ==